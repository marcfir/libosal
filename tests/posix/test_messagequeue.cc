#include "gtest/gtest.h"
#include <pthread.h>
#include <vector>

#include "libosal/mq.h"
#include "libosal/osal.h"
#include "test_utils.h"

namespace test_messagequeue {

using testutils::wait_nanoseconds;

/*
  This is a test which tests the messagequeue with
  multiple producers, multiple consumers.

  The concept is as follows: N producer threads
  write a series of pseudo-random values to
  K destinations. These randon values are
  generated by hashing the sequence of natural
  numbers.

  In order to ensure that the sequence is
  in the right order, the counter is locked for
  each destination, by a per-destination mutex.

  These values are used to form messages,
  which are all sent to the same message queue.

  Then, M consumer threads read the messages from the
  queue, and append them to the destination.
  Appending happens by hashing the previous
  value together with the received message
  value.

  To compare, the sender threads computed the same
  sequence of hashing, and when the threads finish,
  the resulting hashs are compared. If the message
  queue works correctly (preserving both content
  and order of messages), the hashes have to match.


*/

const uint N_PRODUCERS = 30;
const uint M_CONSUMERS = 20;
const uint K_ENDPOINTS = 30;

const ulong NUM_MESSAGES = 1000 * N_PRODUCERS * M_CONSUMERS;
const ulong NUM_MESSAGES_PER_PRODUCER = NUM_MESSAGES / N_PRODUCERS;
const ulong NUM_MESSAGES_PER_CONSUMER = NUM_MESSAGES / M_CONSUMERS;
const ulong MIN_WAIT_TIME_NS = 1000;
const ulong MAX_WAIT_TIME_NS = 100000;

typedef struct {
  uint32_t counter;
  size_t hash;
  pthread_mutex_t source_mutex;
} source_t;

typedef struct {
  uint32_t counter;
  size_t hash;
  pthread_mutex_t dest_mutex;
  //  pthread_cond_t dest_cond;
} dest_t;

typedef struct {
  uint dest_id;
  uint32_t payload;
} message_t;

typedef struct {
  source_t source[K_ENDPOINTS];
  dest_t dest[K_ENDPOINTS];
  pthread_mutex_t receive_lock;
  osal_mq_t queue;
} shared_t;

// combine two hash values (as in a HMAV,
// just not cryptographically secure. */

size_t gethash(uint32_t const n) { return std::hash<uint32_t>{}(n); }

size_t combine_hash(size_t const oldhash, uint32_t const payload) {
  size_t new_hash = std::hash<uint32_t>{}(payload);
  return (oldhash << 4) ^ new_hash;
}

void *run_producer(void *p_params) {

  shared_t *pshared = ((shared_t *)p_params);

  osal_retval_t orv;
  int rv;

  message_t msg;

  for (ulong i = 0; i < NUM_MESSAGES_PER_PRODUCER; i++) {

    // draw a random message id
    msg.dest_id = rand() % K_ENDPOINTS;
    source_t *source = &pshared->source[msg.dest_id];

    // the lock is needed here for two things:
    // 1. to protect the per-thread counter
    // 2. to protect the ordering of messages in respect to that endpoint
    rv = pthread_mutex_lock(&source->source_mutex);
    EXPECT_EQ(rv, OSAL_OK) << "pthread_mutex_lock()[dest] failed";

    source->counter++;
    msg.payload = 0xFFFFFFFF & gethash(source->counter);
    source->hash = combine_hash(source->hash, msg.payload);

    osal_uint32_t const prio = 0;
    orv = osal_mq_send(&pshared->queue, (char *)&msg, sizeof(msg), prio);
    EXPECT_EQ(orv, OSAL_OK) << "osal_mq_send() failed";

    // return dest lock
    rv = pthread_mutex_unlock(&source->source_mutex);
    EXPECT_EQ(rv, OSAL_OK) << "pthread_mutex_unlock()[source] failed";

    // wait a bit to retain some queue capacity
    wait_nanoseconds(rand() % MAX_WAIT_TIME_NS);
  }

  return nullptr;
}

void *run_consumer(void *p_params) {

  shared_t *pshared = ((shared_t *)p_params);

  osal_retval_t orv;
  int rv;

  message_t msg;

  for (ulong i = 0; i < NUM_MESSAGES_PER_CONSUMER; i++) {

    rv = pthread_mutex_lock(&pshared->receive_lock);
    EXPECT_EQ(rv, OSAL_OK) << "pthread_mutex_lock() [mq] failed";
    osal_uint32_t rprio;
    orv = osal_mq_receive(&pshared->queue, (char *)&msg, sizeof(msg), &rprio);
    EXPECT_EQ(orv, OSAL_OK) << "osal_mq_receive() failed";

    dest_t *dest = &pshared->dest[msg.dest_id];
    rv = pthread_mutex_lock(&dest->dest_mutex);
    EXPECT_EQ(rv, OSAL_OK) << "pthread_mutex_lock()[dest] failed";

    dest->counter++;
    dest->hash = combine_hash(dest->hash, msg.payload);

    // return dest lock
    rv = pthread_mutex_unlock(&dest->dest_mutex);
    EXPECT_EQ(rv, OSAL_OK) << "pthread_mutex_unlock()[dest] failed";

    // return mq lock
    rv = pthread_mutex_unlock(&pshared->receive_lock);
    EXPECT_EQ(rv, OSAL_OK) << "pthread_mutex_unlock()[mq] failed";
  }

  return nullptr;
}

TEST(MessageQueue, MultiSendMultiReceive) {

  bool verbose = (getenv("VERBOSE") != nullptr);
  int rv;
  osal_retval_t orv;

  shared_t shared;

  pthread_t producers[N_PRODUCERS];
  pthread_t consumers[M_CONSUMERS];

  // initialize sources
  for (uint i = 0; i < K_ENDPOINTS; i++) {
    shared.source[i].counter = 0;
    shared.source[i].hash = 0;
    rv = pthread_mutex_init(&shared.source[i].source_mutex, nullptr);
    ASSERT_EQ(rv, 0) << "pthread_mutex_init() failed";
  }

  // initialize destinations
  for (uint i = 0; i < K_ENDPOINTS; i++) {
    shared.dest[i].counter = 0;
    shared.dest[i].hash = 0;
    rv = pthread_mutex_init(&shared.dest[i].dest_mutex, nullptr);
    ASSERT_EQ(rv, 0) << "pthread_mutex_init() failed";
  }

  // initialize message queue
  osal_mq_attr_t attr = {};
  attr.oflags = OSAL_MQ_ATTR__OFLAG__RDWR | OSAL_MQ_ATTR__OFLAG__CREAT;
  // attr.oflags = OSAL_MQ_ATTR__OFLAG__RDWR;
  attr.max_messages = 10;
  ASSERT_GE(attr.max_messages, 0u);
  attr.max_message_size = sizeof(message_t);
  ASSERT_GE(attr.max_message_size, 0u);
  attr.mode = S_IRUSR | S_IWUSR;
  // attr.mode = 0666;
  // unlink message queue if it exists
  // the return value is intentionally not checked.
  mq_unlink("/test1");
  errno = 0;
  //
  orv = osal_mq_open(&shared.queue, "/test1", &attr);
  if (orv != 0) {
    perror("failed to open mq:");
  }
  ASSERT_EQ(orv, OSAL_OK) << "osal_mq_open() failed";

  // initialize consumers
  for (uint i = 0; i < M_CONSUMERS; i++) {
    rv = pthread_create(/*thread*/ &(consumers[i]),
                        /*pthread_attr*/ nullptr,
                        /* start_routine */ run_consumer,
                        /* arg */ (void *)&shared);
    ASSERT_EQ(rv, 0) << "pthread_create()[consumers] failed";
  }

  // initialize producers
  for (uint i = 0; i < N_PRODUCERS; i++) {
    rv = pthread_create(/*thread*/ &(producers[i]),
                        /*pthread_attr*/ nullptr,
                        /* start_routine */ run_producer,
                        /* arg */ (void *)&shared);
    ASSERT_EQ(rv, 0) << "pthread_create()[producers] failed";
  }

  // the following waits for all producers to finish first
  // join producers
  for (uint i = 0; i < N_PRODUCERS; i++) {
    rv = pthread_join(/*thread*/ producers[i],
                      /*retval*/ nullptr);
    ASSERT_EQ(rv, 0) << "pthread_join()[producers] failed";
  }

  // join consumers
  for (uint i = 0; i < M_CONSUMERS; i++) {
    rv = pthread_join(/*thread*/ consumers[i],
                      /*retval*/ nullptr);
    ASSERT_EQ(rv, 0) << "pthread_join()[consumers] failed";
  }

  // destroy message queue
  orv = osal_mq_close(&shared.queue);
  ASSERT_EQ(orv, OSAL_OK) << "osal_mq_close() failed";

  // destroy destinations mutexes
  for (uint i = 0; i < K_ENDPOINTS; i++) {
    rv = pthread_mutex_destroy(&shared.dest[i].dest_mutex);
    ASSERT_EQ(rv, 0) << "pthread_mutex_destroy[dest]() failed";
  }

  // destroy sources mutexes
  for (uint i = 0; i < K_ENDPOINTS; i++) {
    rv = pthread_mutex_destroy(&shared.source[i].source_mutex);
    ASSERT_EQ(rv, 0) << "pthread_mutex_destroy[source]() failed";
  }

  // compare results for correctness

  for (ulong i = 0; i < K_ENDPOINTS; i++) {
    EXPECT_EQ(shared.source[i].counter, shared.dest[i].counter)
        << "counters do not match";
  }
  if (verbose) {
    for (ulong i = 0; i < K_ENDPOINTS; i++) {
      printf("hashed values: source = 0x%zx - dest = 0x%zx\n",
             shared.source[i].hash, shared.dest[i].hash);
    }
  }
  for (ulong i = 0; i < K_ENDPOINTS; i++) {
    EXPECT_EQ(shared.source[i].hash, shared.dest[i].hash)
        << "hashes do not match";
  }
}

} // namespace test_messagequeue

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);

  return RUN_ALL_TESTS();
}
